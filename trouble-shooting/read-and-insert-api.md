# Read-and-insert API 중복 요청 방어하기

## 문제 정의

사용자에게 가상 계좌를 할당하는 API 구현을 위해 On-demand 로 할당하기로 결정을 내렸고, 데이터를 읽어서 할당 받지 않은 사용자라면 가상 계좌를 할당하도록 구현했다.

그러나 이러한 read-and-insert 방식에서는 DB에서 첫 번째 요청이 데이터를 읽어 할당하는 사이에 동일한 요청이 여러 번 들어오면 DB에 레코드가 없다고 판단하므로 중복으로 가상 계좌를 할당하는 문제가 발생한다. (a.k.a 따닥이)

따라서 이 문제를 해결하기 위해서는 **한 사용자가 첫 API 요청에 대한 응답을 받기 전까지 다른 요청이 들어오는 경우 무시**해야 한다.

## 문제 해결

### 방법 1. 테이블 락

MySQL은 존재하지 않는 레코드에 대한 레코드 락을 제공하고 있지 않으므로, 다른 트랜잭션이 개입하지 못하게 락을 걸려면 테이블 전체를 잠가야 한다.

Mutex 테이블을 쓰는 방법도 있겠지만 코드 복잡도가 올라가는 건 지양하고 싶다.

어찌됐든 이 방법은 성능 이슈가 있으므로 패스.

### 방법 2. Insert first

사용자 ID 를 Unique Key 로 설정하여 insert를 먼저 하면, 이후에 있을 중복 API 요청을 방어할 수 있다.

1. insert 가 성공하면 select 로 레코드를 가져와서 보여준다.
2. insert가 실패하면 가상 계좌를 할당하고 업데이트 한 뒤 보여준다.
   1. 만약 할당이 실패하면 레코드를 다시 삭제한다.

그러나 Write DB 와 Read DB가 분리되어 있는 서버 인프라 환경이기 때문에 Write DB에 부담을 줄이기 위해 이 방법은 패스.

### 방법 3. API Lock

만약 서버가 인스턴스가 단 하나만 떠 있었다면, 사용자 ID와 Mutex 를 조합해 중복요청을 방어하는 걸 생각해볼 수 있다. 이 방식에서는 `HashMap<UserId, Mutex>` 따위의 In Memory 자료구조를 만들어서 요청이 시작하면 Mutex 를 잠그고, 요청이 완료될 때 Mutex 를 해제한다.

서버 인스턴스가 여러 개라고 하더라도, Memcached 같은 분산 캐시를 이용해 동일한 사용자가 여러 요청을 한 번에 보내는 경우 첫 요청을 제외한 나머지 요청을 무시하도록 구현할 수 있다.

1. 사용자 별로 고유한 ID를 부여한다.
2. 요청이 들어오는 경우, 해당 ID 를 이용해 캐시 키를 만든다.
3. 첫 번째 요청이 들어왔을 때 해당 키로 lock 을 잡는다.
4. 두 번째 요청이 들어왔을 때 캐시 키가 잠겨있다면 Exception 을 throw 한다.

다만, 여러가지 문제점을 함께 고려해야 한다.

* 캐시가 뻗는다거나 서버가 뻗어서 잡았던 lock을 해제하지 못한다면 해당 사용자는 이후 항상 이 요청을 실패한다.
* 모든 분산 캐시 replica 에 락의 획득을 시도하기 때문에 캐시에 트래픽 부담을 주게 된다.

그리고 이것은 어느 정도 완화가 가능하다.

* Lock 에 timeout을 부여한다.
* API Locking 만을 담당하는 캐시를 따로 둔다.

방법 3으로 해결했다.
