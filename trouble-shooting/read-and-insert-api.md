# Read-and-insert API 중복 요청 방어하기

## 문제 정의

사용자에게 가상 계좌를 할당하는 API 구현을 위해 On-demand 로 할당하기로 결정을 내렸고, 데이터를 읽어서 할당 받지 않은 사용자라면 가상 계좌를 할당하도록 구현했다.

그러나 이러한 read-and-insert 방식에서는 DB에서 첫 번째 요청이 데이터를 읽어 할당하는 사이에 동일한 요청이 여러 번 들어오면 DB에 레코드가 없다고 판단하므로 중복으로 가상 계좌를 할당하는 문제가 발생한다. (a.k.a 따닥이)

따라서 이 문제를 해결하기 위해서는 **한 사용자가 첫 API 요청에 대한 응답을 받기 전까지 다른 요청이 들어오는 경우 무시**해야 한다.

## 문제 해결

### 방법 1. 테이블 락

MySQL은 존재하지 않는 레코드에 대한 레코드 락을 제공하고 있지 않으므로, 다른 트랜잭션이 개입하지 못하게 락을 걸려면 테이블 전체를 잠가야 한다.

Mutex 테이블을 쓰는 방법도 있겠지만 코드 복잡도가 올라가는 건 지양하고 싶다.

어찌됐든 이 방법은 성능 이슈가 있으므로 패스.

### 방법 2. Insert first

먼저 데이터를 삽입해놓고, `select ... for update` 로 비관락을 걸면 다른 API 요청이 대기하도록 할 수 있다.

Write 용 DB와 Read 용 DB가 분리되어 있지 않은 환경이라면 합리적인 방법일 수 있었겠지만, 인프라의 이점을 살리기 위해 이 방법도 패스. 심지어 높은 TPS 를 견뎌야 하는 API 이다.

### 방법 3. API Lock

만약 서버가 인스턴스가 단 하나만 떠 있었다면, 사용자 ID와 Mutex 를 조합해 중복요청을 방어하는 걸 생각해볼 수 있다. 이 방식에서는 `HashMap<UserId, Mutex>` 따위의 In Memory 자료구조를 만들어서 요청이 시작하면 Mutex 를 잠그고, 요청이 완료될 때 Mutex 를 해제한다.

서버 인스턴스가 여러 개라고 하더라도, Memcached 같은 분산 캐시를 이용해 동일한 사용자가 여러 요청을 한 번에 보내는 경우 첫 요청을 제외한 나머지 요청을 무시하도록 구현할 수 있다.

1. 사용자 별로 고유한 ID를 부여한다.
2. 요청이 들어오는 경우, 해당 ID 를 이용해 캐시 키를 만든다.
3. 첫 번째 요청이 들어왔을 때 해당 키로 lock 을 잡는다.
4. 두 번째 요청이 들어왔을 때 캐시 키가 잠겨있다면 Exception 을 throw 한다.

다만, 여러가지 문제점을 함께 고려해야 한다.

* 캐시가 뻗는다거나 서버가 뻗어서 잡았던 lock을 해제하지 못한다면 해당 사용자는 이후 항상 이 요청을 실패한다.
* 모든 분산 캐시 replica 에 락의 획득을 시도하기 때문에 캐시에 트래픽 부담을 주게 된다.

그리고 이것은 어느 정도 완화가 가능하다.

* Lock 에 timeout을 부여한다.
* API Locking 만을 담당하는 캐시를 따로 둔다.

방법 3으로 해결했다.
