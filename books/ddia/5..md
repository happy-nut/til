# 5. 복제

1 \~ 4장까지는 책에서의 1부에 해당하는데, 주로 한 시스템에서의 데이터 저장과 그 시스템에 대해 다루었다. 5장부터는 2장인 분산 데이터에 들어가는 내용인데, 이제 한 시스템이 아닌 여러 시스템에 걸쳐 데이터를 처리하는 방법에 대해 이야기하고자 하는 것이고, 그 첫 번째가 바로 복제이다.

이에 앞서 왜 이렇게 **굳이** 데이터를 분산해서 처리하는 걸까? 다음 3가지 이유에서다.

* 확장성
  * 여러 장비에 부하를 분산할 수 있다.
* 내결함성/고가용성
  * 한 장비가 뻗더라도 시스템을 사용할 수 있다.
* 지연 시간
  * 여러 지역적 서버를 두게 되면 지구 반대편에 있는 사용자들도 패킷을 받는 지연 시간이 짧아진다.

이제 왜 분산 데이터가 좋은지 알았다. 데이터를 분산해서 다루려면 일반적으로 복제와 파티셔닝이라는 방식이 사용되는데, 이번 장에서는 먼저 데이터가 충분히 작아 전체 데이터셋의 복사본을 유지할 수 있다는 가정 하에 복제에 대해 다룬다. 이 가정은 파티셔닝에서 좀 더 완화될 것이다.

복제 중인 데이터가 시간이 지나도 변경되지 않는다면 복제는 쉽다. 그러나 변경을 모든 노드에 반영하는 것이 어렵다. 여기에는 주로 3가지 방식이 있다.

* 단일 리더(Single-leader)
* 다중 리더(Multi-leader)
* 리더 없음(Leaderless)

각 방식에는 장단점이 있다.

## 리더와 팔로워

데이터베이스의 복제본을 저장하는 각 노드를 Replica 라고 부른다. 모든 데이터가 모든 replica 에 존재한다는 사실을 보증하려면 DB의 모든 쓰기가 모든 replica 에서도 일어나야 한다. 이를 위해 일반적으로 Leader-based replication 방식을 사용하는데, 다음과 같다.

1. 사용자 A가 프로필 사진을 업데이트 한다.
2. Master Replica 에 업데이트 질의가 전달된다.
3. Master Replica 가 Replication Log 를 생성해 Slave Replica 들에게 보낸다.
4. 다른 사용자 B가 사용자 A의 프로필 사진을 읽을 때는 읽기 전용인 Slave Replica 에서 읽는다.

> Master 와 Slave 는 다음과 같이 불리기도 한다.
>
> * Master: Leader, Primary
> * Slave: Follower, Secondary, Read Replica, Hot standby

### 동기식 대 비동기식 복제

동기식으로 복제를 하면 모든 Slave 가 일관된 데이터를 보유한다는 보장은 할 수 있겠으나, 모든 Slave가 업데이트까지 얼마나 지연이 걸릴지 모른다는 점에서 비현실적이다. 따라서 동기식 복제는 주로 다른 모든 복제는 비동기 식으로 복제를 하되, 단 하나의 Slave만 동기식 복제를 하는 경우에 주로 쓰이는 용어다. 이 방식을 Semi-synchronous 방식이라고 한다.

보통 leader-based replication 은 완전한 비동기 방식으로 구현한다.

### 새로운 팔로워 설정

Slave를 늘리거나 장애난 Slave 를 새로운 Slave 로 교체하는 상황을 떠올려 보자. 다음과 같은 과정이 필요하다.

1. Master 의 DB snapshot 을 일정 시점에 가져온다.
2. 새로운 Slave에 snapshot 을 복사한다.
3. Slave 는 Master 에게 snapshot 이후의 데이터 변경사항(Backlog)을 요청한다.
4. Slave가 Snapshot 이후의 backlog 를 모두 처리하면 Master에게 알려준다.
5. 이제부터 Master 에게 발생하는 데이터 변경을 이어 처리할 수 있다.

### 노드 중단 처리

장애가 나서 노드가 뻗거나, 보안 패치와 같이 계획적으로 노드를 중단시켜야 하는 경우에 시스템 전체가 동작하고 있는 고가용성을 유지하면서 노드의 중단을 처리하는 방법을 알아보자. 크게 Slave 가 뻗는 경우와 Master 가 뻗는 경우가 있을 것이다.

우선 Slave가 뻗는 경우는 간단하다. 로그에서 뻗기 전에 받았던 마지막 트랜잭션을 알아내고, Master 에게 해당 트랜잭션 이후의 모든 변경 사항을 받아오면 된다.

Master가 뻗는 경우는 상당히 까다롭다. 아래의 과정을 거치는데, 이를 Failover(장애 복구) 라고 부른다.

1. 타임아웃과 같은 방법으로 Master 가 장애인지 판단한다.
2. 장애라면, Slave 중 하나를 Master 로 승격한다.
3. 모든 클라이언트가 새로운 Master 를 바라보도록 재설정한다.
4. 다른 Slave 들이 새로운 Master 로부터 데이터 변경사항을 소비하도록 재설정한다.

이 장애 복구가 까다로운 이유는, 위와 같은 과정 중에 충분히 수틀리는 상황들이 발생할 수 있기 때문이다.

* 비동기식 복제인 경우, 새로운 Master 에게 최신 데이터가 누락되었을 수 있다.
* 단순히 위 상황에서 최신 데이터 폐기를 하면 되지 않나? 싶을 수 있는데, Redis로 키를 함께 공유하고 있었다가 일부 사용자에게 엉뚱한 데이터가 공개된 github의 훌륭한 사례가 있다.
* 특정 상황에서 두 노드가 모두 자신이 Master 라고 믿는 상황(Split brain)이 발생할 수 있다.
* 타임아웃이 부적절하면 불필요한 장애 복구가 생기거나 장애가 나더라도 장애 복구를 하지 않게 될 수 있다. 그러나 타임아웃 외에 Master 가 뻗었는지 알아낼만한 도구는 마땅치 않다.

### 복제 로그 구현

"Master 의 변경된 데이터를 Slave 가 받아서 반영한다"

위 내용에 대한 구현방식은 크게 4가지로, 구문 기반 복제, 쓰기전 로그 전송, 로우 기반 로그 복제, 트리거 기반 복제가 있다.

### **구문 기반 복제**

가장 간단한 방식이다. Master 는 지가 받은 쿼리를 똑같이 Slave 에다가도 날린다. 가장 간단한 방식인 만큼 여러 상황에서 복제가 깨질 염려가 있다.

* 쿼리문이 결정적이지 않은 경우: `NOW()`, `RAND()` 와 같은 함수를 쓰는 쿼리.
* `UPDATE ... WHERE <some condition>` 쿼리문: 이미 있는 데이터에 의존하는 쿼리는 각 Replica 가 정확히 같은 순서로 실행되어야 하므로 여러 트랜잭션이 동시에 수행되는 것을 막는다.
* Side effect 를가진 쿼리(trigger, stored procedure, 사용자 정의 함수): Side effect 가 비결정적이라면 Replica 에서 또다른 Side effect 가 발생할 수 있다.

쿼리가 결정적이기만 하다면 이 방법도 쓸만 하다. Master 가 쿼리를 날릴 때 비결정적인 값들을 모두 고정 값으로 만들어 버린다는 해결책도 있으나, 엣지 케이스가 너무 많아 요즘은 일반적으로 다른 복제 방법을 선호한다.

MySQL 5.1 이전 버전에서 사용되던 방식이다.

### **쓰기 전 로그(Write-ahead log, WAL) 전송**

저장소 엔진은 일반적으로 B tree 를 쓰든, LSM tree 를 쓰든 모든 쓰기는 로그에 기록된다. 이 로그를 Slave 에 전달하는 방식이다. 이 로그를 받아 처리한 Slave 들은 Master와 똑같은 구조의 Replica 가 된다.

그러나 여기서 전달되는 로그는 어떤 디스크 블록의 몇 바이트를 수정한다는 내용이 담길 정도로 저수준이기 때문에, 기본적으로 모든 Master 와 Slave 가 같은 DB, 같은 버전을 쓰도록 강제한다. 이는 곧 DB 버전을 업그레이드를 하기 위해서는 시스템 전체 중단이 필요하다는 의미다.

PostgreSQL, Oracle 에서 이 방식을 사용한다.

### **논리적(로우 기반) 로그 복제**

위 방식의 단점을 끊어내기 위해 좀 더 고수준의 로그를 전송하려는 방식이다. 위 방식에 쓰이는 로그를 물리적 로그, 이 방식에서 쓰이는 로그를 논리적 로그라고 부르는 모양이다. 관계형 데이터베이스용 논리적 로그는 로우 단위로 DB 테이블에 쓰기를 기술한 레코드이다.

만약 여러 로우를 수정하는 트랜잭션이 있다면 여러 로그 레코드를 생성한 다음 트랜잭션이 커밋됐음을 레코드에 표시한다.

MySQL의 이진 로그가 이 접근 방식을 사용한다.

### **트리거 기반 복제**

위 3가지 방식은 DB 시스템에 의해 구현된 방식을 사용하는 방식이었으나 좀 더 유연한 상황에 대처하기 위해 애플리케이션 코드로 직접 구현하여 데이터를 복제하기도 한다. 예를 들면 데이터의 서브셋만 복제하고 싶다거나 다른 종류의 DB 로 복제하거나 하는 경우다.

트리거는 쓰기 트랜잭션이 발생하면 등록해놓은 애플리케이션 코드를 실행하는데, 이를 통해 외부 시스템에 데이터를 복제할 수 있다.

## 복제 지연 문제

Leader based replication 은 비동기 복제 방식을 사용하는데, 동기가 오래 걸리게 되면 사용자는 예전 데이터를 보게 된다. 이를 복제 지연이라 한다.

### 자신이 쓴 내용 읽기

자신이 데이터를 쓰기 요청을 할 떄는 Master 에서 처리했는데, 읽으려고 보니 Slave 에서 응답을 받아야 한다. 이때 복제 지연이 발생하면 사용자는 자신의 데이터가 반영이 안되는 불편한 경험을 하게 된다.

이에 대한 대응으로 다음과 같은 방법들이 있다.

* 사용자가 수정한 내용을 읽을 때는 Master 에서 읽는다. 예를 들어, 자신의 프로필은 Master에서 읽고 다른 사람의 프로필은 Slave 에서 읽는다.
* 갱신 시간을 기준으로 1분 이내라면 Master 에서 읽고, 그렇지 않다면 Slave 에서 읽는다.
* 클라이언트가 가장 최근 쓰기의 timestamp 를 기록하고, 질의하는 시점에 timestamp 로 최신 내용인지 검사해 Slave가 동기화 될 때까지 질의를 대기시킨다.

동일한 사용자가 모바일 앱이나 웹, 데스크톱에서 동시에 데이터를 접근할 수 있다면 디바이스 간 일관성이 제공되어야 한다. 이를 위해서는 몇 가지 문제가 추가적으로 고려되어야 한다.

* timestamp 방식은 중앙집중식으로 관리되도록 해야 한다. 한 디바이스에서 발생한 timestamp 를 다른 디바이스가 모르기 때문이다.
* 여러 데이터센터가 분산되어 있는 경우 사용자가 가지고 있는 모든 디바이스의 요청을 동일한 데이터 센터로 라우팅해야 한다.

### 단조 읽기

비동기식 동기화에서는 Slave 간 동기화 속도가 전부 다르기 때문에, 특정 시점에 동기화가 느린 Slave 와 빠른 Slave 가 있을 수 있다.

만약 어떤 데이터가 삽입되었는데, 먼저 빠른 Slave 에서 데이터를 읽어 데이터를 조회했던 사용자가 다시 데이터를 조회할 때는 느린 Slave 에서 데이터를 읽어 원래 보았던 데이터가 없어지는 황당한 경험을 하게 된다.

단조 읽기(monotonic read)는 이런 종류의 현상이 발생하지 않음을 보장한다.

방식은 간단하다. 각 사용자의 읽기가 항상 동일한 Replica 에서 수행되게끔 하면 된다.

### 일관된 순서로 읽기

위 내용이 한 사용자가 여러번 조회를 했을 때 발생하는 문제였다면, 이번엔 질의가 여러번 되었을 때 발생하는 문제를 보자.

```
A: 너 밥 먹었니?
B: 응 먹었어.
```

위와 같은 데이터 (A, B)가 샤딩된 데이터베이스의 각 파티션에 각각 삽입되는 경우, B가 들어간 파티션이 동기화가 더 빠를 때 사용자는 다음과 같은 현상을 관찰하게 된다.

```
B: 응 먹었어.
A: 너 밥 먹었니?
```

여기에 관한 해결책은, 서로 인과성이 있는 쓰기는 동일한 파티션에 기록되게끔 하는 것이다.

### 복제 지연을 위한 해결책

Eventual consistency 를 사용하면 복제 지연은 필수적으로 발생한다.

분산 데이터로 전환되는 과정에서 많은 시스템들이 트랜잭션을 포기했지만, 후에 여기에 대해 더 자세히 다룬다.

## 다중 리더 복제

단일 Master 를 통해 분산 데이터 복제를 처리한다면, 어떤 이유로 Master 에 연결할 수 없는 상황이라면 DB에 쓰기를 할 수 없는 상황이 발생한다. 이를 막기 위해 쓰기를 허용하는 Master를 또하나 두는 것으로 확장시킨 것이 다중 리더 복제다. 서로 다른 Master는 서로의 Slave 가 되어 데이터 변경을 팔로우한다.

### 다중 리더 복제의 사용 사례

단일 데이터센터 내에 다중 리더를 쓰는 것은 복잡도 때문에 바람직 하지 않다. 따라서 여러 데이터센터를 운용하는 경우에 각 데이터 센터에 리더를 하나씩 둠으로써 다중 리더 복제가 사용되곤 한다. 각 데이터센터 안에서는 단일 리더 복제처럼 동작하고, 데이터센터 간에는 리더끼리 데이터를 복제한다.

성능이나 데이터센터 중단 내성, 네트워크 문제 내성과 같은 장점이 생기기 때문에 다중 리더 복제는 언뜻 이상적으로 보이지만 동일한 데이터를 서로 다른 데이터 센터에서 수정하는 경우 쓰기 충돌이 발생한다는 큰 단점이 있다.

이런 문제는 구글 독스같은 동시 편집 애플리케이션에서도 마찬가지로 발생할 수 있는 문제이다.

### 쓰기 충돌 다루기

단일 리더 복제였다면 충돌이 발생하는 두 쿼리중 나중 쿼리를 재시도 하게 하거나 첫 쿼리 중 쓰기 완료될 때까지 두번째 쿼리를 차단하면서 쓰기 충돌을 다룰 수 있다.

그러나 다중 리더 복제에서는 충돌 감지 시점이 비동기적으로 변경 로그를 보낸 시점이기 때문에, 그 때와서 사용자에게 재시도를 요구하기엔 너무 늦다.

가장 쉬운 방법은 충돌 자체를 회피하는 것이다. 예를 들어, 한 사용자의 정보를 여러 사용자들이 수정할 수 있다면 그 권한을 가진 사람들 모두 한 데이터센터의 Master 에서만 쿼리를 날릴 수 있도록 라우팅한다. 그러나 이 경우 부하 분산이나 유연성같은 복제의 장점이 무효화될 수 있다.

일관된 상태로 수렴시키는 것이 쓰기 충돌을 다루는 해법이 될 수 있다.

* 나중에 요청되는 쓰기 요청외에 다른 쓰기를 버린다.
* 각 Replica 에 ID 를 부여하고 높은 숫자의 Replica 의 쿼리를 우선한다.
* 어떻게든 값을 합친다. 예를 들어 문서 제목을 B 로 변경하는 쿼리와 C 로 변경하는 쿼리가 충돌한다면 제목을 B/C 로 만들어버리는 식이다.
* 충돌을 기록해 두고 나중에 사용자에게 보여준 다음 사용자가 직접 해결하게 하는 애플리케이션 코드를 작성한다.

### 다중 리더 복제 토폴로지

복제 토폴로지는 한 노드에서 다른 노드로 쓰기를 전달하는 경로 그래프를 의미한다. 그러나 이 토폴로지 구성에 따라 서로 다른 문제점이 발생할 수 있다.

Circular 토폴로지나 Star 토폴로지는 하나의 노드에 장애가 발생하면 그 장애가 전파된다. 그러나 all-to-all 토폴로지라고 해서 단점이 없는 것도 아닌데, 일부 복제 메시지가 다른 메시지를 추월해 인과적 역전이 발생할 수 있다.

## 리더 없는 복제

모든 Replica 가 클라이언트로부터의 쓰기를 허용하는 방식이 Leaderless 복제이다.

### 노드가 다운됐을 때 데이터베이스에 쓰기

Leaderless 에서는 노드가 하나가 뻗어도 Failover가 필요하지 않다. 단순히 무시한다. 다만 읽을 때 오래된 데이터를 읽는 것을 막기 위해 읽기 요청을 병렬로 여러 노드에 전송한다. 이 때 version number를 이용해 최신 내용만을 처리한다.

그러나 뻗었던 노드는 어떻게 Backlog를 처리해야 할까? 보통 2가지 메커니즘을 사용한다.

* 읽기 복구: 읽기 시에 오래된 응답을 탐지할 수 있게 되는데, 이 때 최신 값으로 오래된 값을 교체한다.
* 안티 엔트로피 처리: 백그라운드 프로세스로 데이터 차이를 지속적으로 찾아다니며 동기화를 한다.

이 밖에 Master 를 하나만 쓰도록 허용하도록 하거나, 그 과정에서 쓰기 충돌을 어떻게 처리해야 하는가에 관한 내용이 책에 담겨있지만, 따로 정리는 하지 않겠다.\
