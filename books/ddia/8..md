---
description: >-
  네트워크가 끊기거나, 타이밍 이슈 등을 어떻게 회피할 수 있을까? 또, 종잡을 수 없는 분산 시스템의 상태를 무슨 일이 일어났던 것인지
  어떻게 추론할 수 있을까.
---

# 8. 분산 시스템의 골칫거리

## 결함과 부분 장애

분산 시스템을 다루기 어려운 이유는 부분 장애와 비결정성 때문이다.

시스템의 어떤 부분은 잘 동작하지만 다른 부분이 예측할 수 없는 방식으로 고장나는 걸 **부분 장애(partial failure)**라고 하고, 이러한 부분 장애는 비결정적이다. 즉, 100번 실행했을 때 100번 다 똑같은 결과를 반환하는 걸 보장하지 않는다.

### 클라우드 컴퓨팅과 슈퍼컴퓨팅

슈퍼컴퓨팅은 흔히 부분 장애가 발생하면 전체 장애로 확산시켜 클러스터 자체를 중단시켜 버린다(마치 단일 장비의 커널 패닉처럼). 그러나 클라우드 컴퓨팅은 그런 짓을 했다가는 모가지가 날아가기 때문에, 언제든 부분 장애가 발생할 수 있다는 가능성을 받아들이고 시스템 안에 내결함성을 위한 메커니즘을 잘 녹여내야 한다.

클라우드 컴퓨팅을 구축할 때 만큼은 의심, 비관, 편집증이 빛을 발한다. 우리는 **신뢰성이 없는 구성요소들로 신뢰성이 있는 시스템을 만들어야 하기 때문**이다.

## 신뢰성 없는 네트워크

분산 시스템에서 각 노드들에게 네트워크는 서로가 통신하는 유일한 수단이다. 그러나 네트워크는 신뢰성이 없다. 다른 노드로 요청을 보내서 응답을 받지 못했다면 정확히 그 이유를 아는 것은 불가능하기 때문이다.

1. 요청이 손실되었는지 알 수 없다.
2. 원격 노드가 다운되었는지 알 수 없다.
3. 응답이 손실되었는지 알 수 없다.

흔히 타임아웃으로 이 문제를 해결하고자 하지만, 원격 노드가 응답을 받았는지 아닌지는 여전히 알 수 없다.

### 현실의 네트워크 결함

네트워크 결함은 언제든지 발생할 수 있으므로 소프트웨어가 이를 잘 처리할 수 있게 해야 한다. 우리는 네트워크 문제에 소프트웨어가 어떻게 반응하는지 알아야 하고, 신뢰성 높은 시스템을 만들기 위해 고의로 네트워크 문제를 유발시켜 시스템 반응을 테스트를 해보는 것도 나쁘지 않은 선택이다.

### 결함 감지

분산 시스템에서 결함이 있는 노드를 자동으로 감지할 수 있어야 한다.

* 로드 벨런서가 죽은 노드로 요청을 그만 보내야 한다.
* Master가 장애나면 Slave가 Master로 승격되어야 한다.

그러나 네트워크가 간직한 불확실성 때문에 노드가 동작 중인지 구별하기 어렵다.

따라서 보통은 죽었거나 죽어가는 노드로부터 결함 있음을 전달받는 걸 기대하기 보다, 응답 받지 못하는 경우를 장애가 난 것으로 판단한다(재시도와 타임아웃을 곁들여서).

### 타임아웃과 기약 없는 지연

타임아웃은 너무 짧거나 길면 문제가 된다.

타임아웃이 너무 길면:

* 사용자는 오랫동안 기다리거나 오류메시지를 봐야 한다.

타임아웃이 너무 짧으면

* 노드가 실제로는 살아있는데 다른 노드에게 동작이 위임되면서 2번 실행된다.
* 부하로 인해 느려진 노드를 죽었다고 판단하면 다른 노드들에 그 부하가 가중된다.

사실 완벽한 타임아웃 시간을 정하려면 네트워크 최대 지연시간 \* 2(왕복) + 시스템의 처리 시간으로 구해야 하지만, 비동기 네트워크의 경우 기약 없는 지연(unbounded delay)이 있고 대부분의 시스템은 정해진 최대 시간 내에 요청을 처리한다고 보장할 수 없다.

결국 실험적으로 타임아웃을 결정해야 한다.

* 네트워크 응답 시간의 분포를 계산하여 적절한 타임아웃을 구한다.
* 시스템이 자동으로 응답 시간과 변동성(jitter)을 측정하고 타임아웃을 조절하게 한다.

## 신뢰성 없는 시계

### 단조 시계 대 일 기준 시계

### 시계 동기화와 정확도

### 동기화된 시계에 의존하기

### 프로세스 중단

## 지식, 진실, 그리고 거짓말

### 진실은 다수결로 결정된다

### 비잔틴 결함

### 시스템 모델과 현실

\
