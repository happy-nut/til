# 3장. 컨텍스트 맵

2장에서는 문제점 공간 평가에 관해 초점을 맞추었다면, 여기서는 해결책 공간 평가에 초점을 맞춘다.  

## 컨텍스트 맵이 필수적인 이유

DDD를 위한 노력을 처음 시작할 때 현재 프로젝트 상황의 시각적 컨텍스트 맵을 먼저 그리자. 컨텍스트 맵은 우리 팀이 성공하기 위해 필요한 해결책 공간의 관점을
제공하기 위한 목적에 초점을 두고 그려져야 한다.

![](.gitbook/assets/ddd_4.png)

위 그림에서 통합을 나타내는 선 위의 U는 Upstream(상위 위치), D는 Downstream(하위 위치)을 뜻한다.

위와 같이 초기에 컨텍스트 맵을 그리면 우리가 의지하는 모든 다른 프로젝트들과의 관계를 신중히 생각해보도록 강요받게 된다.

### 컨텍스트 맵 그리기

컨텍스트 맵 다이어그램은 복잡할 필요가 없다. 미래를 나타낼 필요도 없다. 너무 많은 세부내용을 추가하는 것은 실질적 도움이 되지 못한다.
다만, 많은 대화를 팀과 해야 한다. 그 대화를 통해 전략적 통찰이 드러나는 순간, 컨텍스트 맵에 반영하면 된다.

경계의 위치, 경계와 팀 사이의 관계, 포함돼있는 통합의 유형, 이들 사이에 필요한 변환이 무엇인지 높은 수준에서 이야기하며 그려야 한다.

### 프로젝트와 조직 관계

바운디드 컨텍스트 통합의 유형은 다음과 같다.

* 파트너십(Partnership): 협업 관계이다. 각 컨텍스트에서는 양측 시스템 모두의 개발 요구를 수용할 수 있는 인터페이스를 만들어 나가기 위해 반드시 협력한다.
상호 의존적인 기능은 반드시 일정을 세워 같은 릴리스에서 완성할 수 있도록 한다.

* 공유 커널(Shared Kernel): 모델에서 공유된 부분과 이에 관련된 코드는 아주 가까운 상호 의존성을 형성한다. 도메인 모델에서 팀이 공유하기로 동의한 부분 집합
일부를 명시적 경계로 지정한다. 커널 모델을 단단하게 유지하고 팀의 유비쿼터스 언어를 정돈해주는 지속적 통합 프로세스를 정의해야 한다.

* 고객-공급자 개발(Customer-Supplier Development): 두 팀이 업스트림과 다운스트림의 관계에 있고 업스트림 팀의 성공이 다운스트림 팀의 운명과 상호의존적이다.
업스트림 계획이 다운 스트림 우선 순위에 영향을 미친다. 협상과 작업 예산 편성을 다운 스트림의 요구사항에 맞춰 진행해서 모든 사람에게 약속과 일정을 이해시켜야 한다.

* 순응주의자(Conformist): 업스트림 팀이 다운스트림 팀의 요구사항을 제공해줄 동기가 전혀 없는 업스트림/다운스트림 관계에서 다운스트림 팀은 속수무책의 상황에 빠진다.
다운스트림 팀은 맹목적으로 업스트림 팀의 모델을 준수해서, 바운디드 컨텍스트 사이에 나타나는 변환의 복잡성을 제거한다.
  
* 부패 방지 계층(Anticorruption Layer, ACL): 변환 계층은 협조적인 팀 사이에서 잘 설계된 바운디드 컨텍스트를 연결할 때 간결하고 우아해질 수 있다.
다운 스트림 클라이언트에는 분리 계층을 만들어서 업스트림 시스템의 기능을 자신이 소유한 도메인 모델의 맥락에 맞춰 제공한다. 이 계층은 기존의 인터페이스를 통해
  다른 시스템과 대화하며, 다른 시스템을 수정할 필요가 거의 없다. 이 계층은 내부적으로 필요에 따라 단방향이나 양방향으로 두 모델 사이에서 변환을 수행한다.
  기술적으로는 리포지토리 인터페이스 뒤에 위치시킬 수도 있다. 다운스트림 ACL은 PL을 로컬 컨텍스트의 도메인 객체로 변환해준다.
  
* 오픈 호스트 서비스(Open Host Service, OHS): 서브시스템에 접근할 수 있도록 해주는 서비스 집합으로서의 프로토콜을 정의한다. 공유된 프로토콜이 단순함과 일관성을 유지하도록 해야 한다.
기술적으로는 REST 기반 리소스나 RPC(Remote Procedure Call) API로 구현할 수 있다. 

* 발행된 언어(Published Language, PL): 두 바운디드 컨텍스트 모델 사이의 변환은 공통 언어를 필요로 한다. 이는 종종 오픈 호스트 서비스와 결합된다.
기술적으로 XML, JSON, Protocol buffer 등을 통해 표현할 수 있다. 또, 도메인 이벤트가 관계된 구독자에게 메시지를 전달하는 이벤트 주도 아키텍쳐에서도 사용될 수 있다.

* 분리된 방법(Seperate Ways): 서로가 완전히 분리된다. 바운디드 컨텍스트가 다른 것과 아무 연관이 없음을 선포해서 작은 범위 내에서 솔루션을 찾아야 한다.

* 큰 진흙공(Big Ball of Mud): 여러 모델이 서로 뒤섞이고 경계는 일정하지 않은 상황에서 시스템을 구성하는 부분들을 찾게 된다. 이런 어지러운 상황 전체를
아우르는 경계를 큰 진흙공으로 선언하고, 이 안에 세련된 모델링을 적용하려 애쓰지 말자. 그 대신 이런 시스템이 다른 컨텍스트 안으로 제멋대로 퍼져나가지 못하도록 해야 한다.
  
### 세 가지 컨텍스트를 매핑하기

세 가지 제품을 개발하고 수정하고 있는 회사의 이야기로 설명한다.

1. 등록된 사용자가 포럼, 공유 일정, 블로그, 위키 등과 같은 인기 있는 웹 기반 도구를 사용해 비즈니스 가치가 있는 콘텐츠를 게시할 수 있도록 한다.

   이는 이 회사의 주력 제품이자, 회사의 첫 번째 핵심 도메인이었다. 이 컨텍스트로부터 2번 제품의 모델을 뽑아낼 수 있었고, 이제 이 협업 컨텍스트는 2번 제품의
   컨텍스트인 식별자와 액세스 도메인을 범용 서브 도메인으로 사용한다. 협업 컨텍스트는 3번 제품인 애자일 프로젝트 관리 도메인의 선택적 에드온이 된다.

2. 재사용 가능한 식별자와 액세스 관리 모델이며, 등록된 사용자를 위한 안전한 역할 기반 액세스 관리를 제공한다. 주요 제품 특징은 여러 테넌트를 지원한다는 점인데,

   식별자와 액세스 도메인은 자신을 사용하는 모델에게 범용 서브도메인의 역할을 제공한다.

3. 애자일 프로젝트 관리 제품은 새로운 핵심 도메인이다. 사용자는 프로젝트 관리 자산을 생성할 수 있을 뿐 아니라 분석과 설계에 따른 산출물도 만들어주며,
   스크럼 기반의 실행 프레임워크를 사용해 진행 상황 추적도 가능하게 한다. 1번 제품과 함께, 3번 제품은 2번 제품을 범용 서브 도메인으로 사용한다.

이 회사의 컨텍스트 맵은 아래와 같다.

![](.gitbook/assets/ddd_5.png)

Upstream(제공해주는 쪽)은 DownStream(사용하는 쪽)보다 위 쪽에 표시한다. 강의 상류가 하류에 영향을 미치듯이, Upstream의 변화는 Downstream에
영향을 미친다. 따라서 Downstream쪽에서는 부패를 방지하기 위한 ACL을 세운다.

식별자와 액세스 컨테스트와 연결된 협업 컨텍스트 관계를 확대해서 살펴보자.

![](.gitbook/assets/ddd_6.png)

흔히 생각하는 REST 요청을 통해 데이터를 가져오는 방식이다.
식별자와 액세스 컨텍스트에서 중개자의 `Role`을 수행하는 `User`가 협업 컨텍스트의 `Moderator` 값 객체로 변환된다.
(아마도, 그림에서의 `CollaboratorService`가 아니라 `ModeratorService` 아니었을까... `CollaboratorService`는 2장의 컨텍스트 다이어그램에 나오지도 않았다. 점점 책이나 번역의 퀄리티에 의구심이 들기 시작한다)

이번엔 식별자와 액세스 컨테스트와 연결된 애자일 프로젝트 관리 컨텍스트 관계를 확대해서 살펴보자.

![](.gitbook/assets/ddd_7.png)

위의 경우에서는 OHS/PL + ACL로 REST를 사용하고 있는데, `MemberSynchronizer`가 `MemberService`의 `maintainMembers()`를 주기적으로 호출하여
알림 싱크를 맞추고 있는 구조다. 여기서 한 가지 알아둘 점은 OHS/PL + ACL이라고 해서 REST만 사용할 수 있는 것은 아니다. 위의 경우에서는 메시징 인프라스트럭처를 고민해 볼 수도 있다.

이제, 협업 컨텍스트와 애자일 프로젝트 관리 컨텍스트의 관계를 확대해서 살펴보자.

![](.gitbook/assets/ddd_8.png)

여기선 아주 흥미로운 상황이 펼쳐진다. 협업 컨텍스트에서 `Discussion`은 Aggregate 이고 `Post`의 집합을 관리했다. 애자일 프로젝트 관리 컨텍스트에서
`Discussion`은 Value Object로서 오직 외부 컨텍스트에 있는 실제 `Discsussion`과 그에 따른 `Post`를 참조만 할 뿐이다.
그러나 이런 상황이라면 지금처럼 그대로 가져다 쓰는 것이 아니라 여러 토론의 종류를 분명한 타입으로 입력하는 것이 좋다.

```java
public enum DiscussionAvailability {
  ADD_ON_NOT_ENABLED, NOT_REQUESTED, REQUESTED, READY;
}

public final class Discussion implements Serializable {
  private DiscussionAvailability availability;
  private DiscussionDesciptor desciptor;
  ... 
}

public class Product extends Entity {
  ...
  private Discussion discussion;
  ...
}
```

이 설계를 통해, `DiscussionAvailability`로 정의한 상태가 `Discussion` Value Object를 잘못된 사용으로부터 보호해준다.

`Discussion` 이 생성되고 결과가 로컬 컨텍스트에 전달되면, 비동기 컴포넌트(메시지 핸들러나 RPC 클라이언트)는 `Product`에게 `attachDiscussion()`
을 할 수 있도록 알려주면서 새로 생성된 `Discussion` 인스턴스를 전달한다. 보류 중인 모든 원격 리소스를 가지고 있는 로컬 Aggregate은 이런 방식으로 관리된다.
